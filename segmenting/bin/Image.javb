package image;

import geometry.Mesh;
import java.awt.image.BufferedImage;
import java.awt.Color;
import java.io.IOException;
import java.io.PrintWriter;
import javax.swing.JOptionPane;
import javax.swing.JFileChooser;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Iterator;
import java.util.TreeSet;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.File;
import javax.imageio.ImageIO;
import java.io.IOException;
import javax.swing.*;

/* Picture similarity: Color difference!
 * OR AA to match sizes (reduce if possible; enlarging is insensible because smaller cannot expound detail)
 * Account for variable distortions
 * Generate 'Checksum' image closeness (a la compareTo())
 * OR Color edge b/w images 
*/

// "Grow"-regions for similarity: like comparing two directories or computers for similarities,
// where identical or uniquely identifiable contiguous blocks are grouped together.
// future implementation: regions are fluid, such that portions may split to belong to separate 
// regions, or merge into one unique region.

/* Vectorization algorithm
 * Weighted considerations:
 * Linearity (or curve closeness)
 * Average difference (contrast)
 * Anti-alias sharpness
 * Color closeness per side of region
 * Material (region) uniformity
 * Self-similarity
 * Marching squares mathematical revision: precision! 
 */

// All sobel contrast images can be scaled down by a factor of two because contrasts will always occur in pairs (a->b, b->a)
	// Comparison simulator: gravitate towards similar colors
	// Positional tendency for gravitation rather than acceleration
	// i.e. average seeker and target coordinates for new seeker coordinates on each clock
	

public class Image {
	public static boolean debug = false;
	public static final int ALPHA = 0x00FF000000;
	public static final int RED = 0x0000FF0000;
	public static final int GREEN = 0x000000FF00;
	public static final int BLUE = 0x00000000FF;
	
	public static int[][][] toArray(BufferedImage image) {
		int[][][] array = new int[image.getWidth()][image.getHeight()][3];
		for (int x = 0; x<image.getWidth()-1; x++) {
			for (int y = 0; y<image.getHeight()-1; y++) {
				Color color = new Color(image.getRGB(x,y));
				array[x][y][0] = color.getRed();
				array[x][y][1] = color.getGreen();
				array[x][y][2] = color.getBlue();
			}
		}
		return array;
	}

	public static BufferedImage subtract(BufferedImage image1, BufferedImage image2) {
		BufferedImage output = new BufferedImage(image1.getWidth(), image1.getHeight(), image1.getType());
		//assumes images are the same size
		//image2 = scale(image2, image1.getWidth() / image2.getWidth(), image1.getHeight() / image2.getHeight()); 
		for (int x = 0; x<image1.getWidth(); x++) {
			for (int y = 0; y<image1.getHeight(); y++) {
				Color color1 = new Color(image1.getRGB(x,y));
				Color color2 = new Color(image2.getRGB(x,y));
				//int color = color1.getRGB() - color2.getRGB();
				int color = (new Color(Math.abs(color1.getRed() - color2.getRed()), Math.abs(color1.getGreen() - color2.getGreen()), Math.abs(color1.getBlue() - color2.getBlue()))).getRGB();
				output.setRGB(x, y, color);
			}
		}
		return output;
	}

	public static int summate(int[][][] array3d, boolean abs) {
		int result = 0;
		for(int i = 0; i < array3d.length; i++)
			result += summate(array3d[i], abs);
		return result;
	}

	public static int summate(int[][] array2d, boolean abs) {
		int result = 0;
		for(int i = 0; i < array2d.length; i++)
			result += summate(array2d[i], abs);
		return result;
	}

	public static int summate(int[] array1d, boolean abs) {
		int result = 0;
		if(abs)
		for(int i = 0; i < array1d.length; i++)
			result += Math.abs(array1d[i]);
		else
		for(int i = 0; i < array1d.length; i++)
			result += array1d[i];
		return result;
	}


	public static BufferedImage scale(BufferedImage image, double percent) {
		return scale(image, percent, percent);
	}

	public static BufferedImage scale(BufferedImage image, double percentx, double percenty) {
		return scale(image, (int)(percentx * image.getWidth()), (int)(percenty * image.getHeight()));
	}

	public static BufferedImage scale(BufferedImage image, int newX, int newY) {
		double width = image.getWidth(), height = image.getHeight();
		double ratioX = newX / width, ratioY = newY / height;
		BufferedImage output = new BufferedImage(newX, newY, image.getType());
		//double stdArea =  ratioX * ratioY;
		for (int x = 0; x<newX; x++) {
			for (int y = 0; y<newY; y++) {
				int r = 0, g = 0, b = 0;
				double area = 0;
				for(double u = x / ratioX; u < (x + 1) / ratioX && (u) < width; u++) {
					for(double v = y / ratioY; v < (y + 1) / ratioY  && (v) < height; v++) {
						//rough scale: unweighted areas
						area++;
						
						//area = ((u - Math.min(((x + 1) / ratioX), u+1))*(v - Math.min(((y + 1) / ratioY), v+1));
						//area += stdArea;
						int col = image.getRGB((int)((u)), (int)((v)));
						Color color = new Color(col);
						r += color.getRed();//*area;
						g += color.getGreen();//*area;
						b += color.getBlue();//*area;
					}
				}
				r /= area;
				g /= area;
				b /= area;
				output.setRGB(x, y, (new Color(r, g, b)).getRGB());
			}
		}
		return output;
	}

	// Determines whether the contents of any two images are identical, pixel-for-pixel.
	public static boolean equal(BufferedImage image1, BufferedImage image2) {
		if(image1.getWidth() != image2.getWidth() || image1.getHeight() != image2.getHeight()) return false;
		for (int x = 0; x<image1.getWidth(); x++) {
			for (int y = 0; y<image1.getHeight(); y++) {
				int color1 = (new Color(image1.getRGB(x,y))).getRGB();
				int color2 = (new Color(image2.getRGB(x,y))).getRGB();
				if(color1 != color2) return false;
			}
		}
		return true;
	}

	public static int absoluteDifference(BufferedImage image1, BufferedImage image2) {
		return summate(toArray(subtract(image1, image2)), true);
	}

	public static int scaledDifference(String imageFile1, String imageFile2) throws IOException {
			BufferedImage image1 = ImageIO.read(new File(imageFile1));
			BufferedImage image2 = ImageIO.read(new File(imageFile2));
			return scaledDifference(image1, image2);
	}
	public static int scaledDifference(BufferedImage image1, BufferedImage image2) {
		if(image1.getWidth() * image1.getHeight() > image2.getWidth() * image2.getHeight())
			image2 = scale(image2, image1.getWidth(), image1.getHeight());
		return summate(toArray(subtract(image1, image2)), true);
	}
	
	// Output similarity map option
	// Grow out of similar color finding THEN formulate and check a region!
	// One step back: determine uniqueness of points based on anticontiguity
	// Most important factor is relative placement of points!
	public static int[] findMatchingPoint(BufferedImage image1, BufferedImage image2, int x, int y, int diameter) {
		int[] closest = new int[3];
		closest[0] = image2.getWidth() -1;
		closest[1] = image2.getHeight() -1;
		closest[2] = Integer.MAX_VALUE;
		//Acquire region 1
		BufferedImage region = new BufferedImage(diameter, diameter, image1.getType());
		for(int u = 0; u < diameter && u < image1.getWidth(); u++)
			for(int v = 0; v < diameter && v < image1.getHeight(); v++)
			region.setRGB(u, v, image1.getRGB(u+x, v+y));
		
		for(int u = 0; u < image2.getWidth() - diameter; u++)
			for(int v = 0; v < image2.getHeight() - diameter; v++) {
				//Acquire region 2
				BufferedImage region2 = new BufferedImage(diameter, diameter, image2.getType());
				for(int a = 0; a < diameter && a < image2.getWidth(); a++)
					for(int b = 0; b < diameter && b < image2.getHeight(); b++)
					region2.setRGB(a, b, image2.getRGB(u+a, v+b));
				//Compare regions
				int diff = absoluteDifference(region, region2);
				if(diff < closest[2]) {
					closest[2] = diff;
					closest[0] = u;
					closest[1] = v;
				}
			}
		return closest;
	}
	// Similarity map
	public static BufferedImage difference(BufferedImage image1, BufferedImage image2, int x, int y, int diameter) {
		BufferedImage output = new BufferedImage(image2.getWidth() - diameter, image2.getHeight() - diameter, image1.getType());
		int[] closest = new int[3];
		closest[0] = image2.getWidth() -1;
		closest[1] = image2.getHeight() -1;
		closest[2] = Integer.MAX_VALUE;
		//Acquire region 1
		BufferedImage region = new BufferedImage(diameter, diameter, image1.getType());
		for(int u = 0; u < diameter && u < image1.getWidth(); u++)
			for(int v = 0; v < diameter && v < image1.getHeight(); v++)
			region.setRGB(u, v, image1.getRGB(u+x, v+y));
		
		for(int u = 0; u < image2.getWidth() - diameter; u++)
			for(int v = 0; v < image2.getHeight() - diameter; v++) {
				//Acquire region 2
				BufferedImage region2 = new BufferedImage(diameter, diameter, image2.getType());
				for(int a = 0; a < diameter && a < image2.getWidth(); a++)
					for(int b = 0; b < diameter && b < image2.getHeight(); b++)
					region2.setRGB(a, b, image2.getRGB(u+a, v+b));
				//Compare regions
				int diff = absoluteDifference(region, region2);
				output.setRGB(u,v,(new Color(255-diff/4,255-diff/4,255-diff/4)).getRGB());
			}
		return output;
	}
	
	public static int[] findClosestPoint(BufferedImage image1, BufferedImage image2, int x, int y, int diameter) {
		int[] closest = new int[3];
		closest[0] = image2.getWidth() -1;
		closest[1] = image2.getHeight() -1;
		closest[2] = Integer.MAX_VALUE;
		//Acquire region 1
		Color c = new Color(image1.getRGB(x,y));
		double[] color1 = {c.getRed(), c.getGreen(), c.getBlue()};
		BufferedImage region = new BufferedImage(diameter, diameter, image1.getType());
		for(int u = 0; u < diameter && u < image1.getWidth(); u++)
			for(int v = 0; v < diameter && v < image1.getHeight(); v++)
				if(u+x < image1.getWidth() && u+x >= 0 && v+y < image1.getHeight() && v+y >=0)
				region.setRGB(u, v, image1.getRGB(u+x, v+y));
		
		for(int u = 0; u < image2.getWidth() - diameter; u++)
			for(int v = 0; v < image2.getHeight() - diameter; v++) {
				Color d = new Color(image2.getRGB(u,v));
				double[] color2 = {d.getRed(), d.getGreen(), d.getBlue()};
				if(math.Math3D.distance(color1, color2) > closest[2]) continue;
				
				//Acquire region 2
				BufferedImage region2 = new BufferedImage(diameter, diameter, image2.getType());
				for(int a = 0; a < diameter && a < image2.getWidth(); a++)
					for(int b = 0; b < diameter && b < image2.getHeight(); b++)
					region2.setRGB(a, b, image2.getRGB(u+a, v+b));
				//Compare regions
				int diff = absoluteDifference(region, region2);
				//Counter distance by weight for closeness
				double[] l1 = {x,y}, l2 = {u,v}; 
				diff += (math.Math3D.distance(l1, l2))/10;
				if(diff < closest[2]) {
					closest[2] = diff;
					closest[0] = u;
					closest[1] = v;
				}
			}
		return closest;
	}

	public static BufferedImage sobelColor (BufferedImage input) {
		ImageArray img = new ImageArray(input);
		BufferedImage output = img.toImage();
		for (int x = 0; x<input.getWidth()-2; x++) {
			for (int y = 0; y<input.getHeight()-2; y++) {
				double gxR = Math.abs(img.array[x][y][1]+img.array[x+1][y][1]*2+img.array[x+2][y][1]-
						(img.array[x][y+2][1]+img.array[x+1][y+2][1]*2+img.array[x+2][y+2][1]));
				double gyR = Math.abs(img.array[x][y][1]+img.array[x][y+1][1]*2+img.array[x][y+2][1]-
						(img.array[x+2][y][1]+img.array[x+2][y+1][1]*2+img.array[x+2][y+2][1]));
				int edgeR = (int)(Math.sqrt(gxR*gxR+gyR*gyR)/5.67);

				double gxG = Math.abs(img.array[x][y][2]+img.array[x+1][y][2]*2+img.array[x+2][y][2]-
						(img.array[x][y+2][2]+img.array[x+1][y+2][2]*2+img.array[x+2][y+2][2]));
				double gyG = Math.abs(img.array[x][y][2]+img.array[x][y+1][2]*2+img.array[x][y+2][2]-
						(img.array[x+2][y][2]+img.array[x+2][y+1][2]*2+img.array[x+2][y+2][2]));
				int edgeG = (int)(Math.sqrt(gxG*gxG+gyG*gyG)/5.67);

				double gxB = Math.abs(img.array[x][y][3]+img.array[x+1][y][3]*2+img.array[x+2][y][3]-
						(img.array[x][y+2][3]+img.array[x+1][y+2][3]*2+img.array[x+2][y+2][3]));
				double gyB = Math.abs(img.array[x][y][3]+img.array[x][y+1][3]*2+img.array[x][y+2][3]-
						(img.array[x+2][y][3]+img.array[x+2][y+1][3]*2+img.array[x+2][y+2][3]));
				int edgeB = (int)(Math.sqrt(gxB*gxB+gyB*gyB)/5.67);

				int color = (new Color(edgeR, edgeG, edgeB)).getRGB();
				output.setRGB(x+1,y+1,color);
			}
		}
		return output;
	}
	
	public static void flag() {
		System.out.println("Flag~!");
	}

	// What we need here is a multidimensional hash-like set that doesn't take up as much space as a hash cube.
/*	private class PointSet {
		//public TreeSet<Point> points;
		public int radius;
		public static int VALUES = 256;
		public Point[][][] set;
		PointSet() {
			radius = 4; //<- 64 Permutations that are all considered same color
			//points = new TreeSet<Point>();
			set = new Point[VALUES / radius][VALUES / radius][VALUES / radius];
		}

		PointSet(int radius) {
			this.radius = radius;
			set = new Point[VALUES / radius][VALUES / radius][VALUES / radius];
		}
		
		public boolean add(int[] color, int[] contrast, int[] loc) {
			return add(new Point(color, contrast, loc));
		}

		public boolean add(Point p) {
			if(set[p.contrast[0] / radius][p.contrast[1] / radius][p.contrast[2] / radius] != null) {
				set[p.color[0] / radius][p.color[1] / radius][p.color[2] / radius] = p;
				return true;
			}
			return false;
		}
	}

	private class PointSet {
		//public TreeSet<Point> points;
		public int radius;
				

	}

	private class Point implements Comparable {
		private int[] color, contrast, loc;
		public Point(int[] color, int[] contrast, int[] loc) {
			this.color = color;
			this.contrast = contrast;
			this.loc = loc;
		}
		
		// return an int such that similar points will be grouped closely
		public int compareTo(Object o) {
			int result = 0;
			Point p = (Point) o;
			for(int i = 0; i < 3; i++) {
				result += Math.abs(p.color[i]-color[i]) + Math.abs(p.contrast[i]-contrast[i]);  
			}
		}

	} */

	public static BufferedImage suppress (BufferedImage input) {
		BufferedImage output = new BufferedImage(input.getWidth(), input.getHeight(), input.getType());
		ImageArray img = new ImageArray(input);
		for (int x = 0; x<input.getWidth()-3; x++) {
			for (int y = 0; y<input.getHeight()-3; y++) {
				double gx = Math.abs(colorDist(img.array[x][y][0])+colorDist(img.array[x+1][y][0])*2+colorDist(img.array[x+2][y][0])-
						colorDist(img.array[x][y+2][0])+colorDist(img.array[x+1][y+2][0])*2+colorDist(img.array[x+2][y+2][0]))/4;
				double gy = Math.abs(colorDist(img.array[x][y][0])+colorDist(img.array[x][y+1][0])*2+colorDist(img.array[x][y+2][0])-
						colorDist(img.array[x+2][y][0])+colorDist(img.array[x+2][y+1][0])*2+colorDist(img.array[x+2][y+2][0]))/4;
				boolean vmax=false, hmax=false;
				if (colorDist(img.array[x+1][y][0]) < colorDist(img.array[x+1][y+1][0]) && colorDist(img.array[x+1][y+2][0]) <= colorDist(img.array[x+1][y+1][0]))
					vmax = true;
				if (colorDist(img.array[x][y+1][0]) < colorDist(img.array[x+1][y+1][0]) && colorDist(img.array[x+2][y+1][0]) <= colorDist(img.array[x+1][y+1][0]))
					hmax = true;
				int result = img.array[x+1][y+1][0];
				if (((gx>gy && hmax) || (gy>gx && vmax)) || (hmax && vmax)) { 
					if(result > Color.white.getRGB())
						result =  Color.white.getRGB();
					output.setRGB(x+1,y+1,result);
				}
				else
					output.setRGB(x+1,y+1,Color.black.getRGB());
			}
		}
		return output;
	}

	public static BufferedImage suppressVH (BufferedImage input) {
		int height = input.getHeight(), width = input.getWidth();
		BufferedImage output = new BufferedImage(width, height, input.getType());
		ImageArray img = new ImageArray(input);
		double[] hmax = new double[height];
		double[] hsign = new double[height];
		for(int i = 0; i < height; i++) {
			hmax[i] = 0;
			hsign[i] = 1;
		}
		for (int x = 1; x<width-1; x++) {
			double vmax = 0;
			double vsign = 1;
			for (int y = 1; y<height-1; y++) {
				boolean set = false;
				double dist = colorDist(input.getRGB(x,y));
				if(dist*vsign >= vmax*vsign) {
					vmax = dist;
				}
				else { // vertical local maximum or minimum
					if(vsign == 1) { // maximum
						//output.setRGB(x,y,input.getRGB(x,y));
						set = true;
					}
					vmax = Double.NEGATIVE_INFINITY;
					vsign *= -1;
				}
				if(dist*hsign[y] >= hmax[y]*hsign[y]) {
					hmax[y] = dist;
				}
				else {
					if(hsign[y] == 1) {
						if(set)
						output.setRGB(x,y,input.getRGB(x,y));
					}
					hmax[y] = Double.NEGATIVE_INFINITY;
					hsign[y] *= -1;
				}
			}
		}
		return output;
	}

	public static double colorDist(int color) {
		return distance(new Color(color), new Color(0));
	}
	
	public static BufferedImage edge3 (BufferedImage input) {
		BufferedImage output = new BufferedImage(input.getWidth(), input.getHeight(), input.getType());
		for (int x = 0; x<input.getWidth()-2; x++) {
			for (int y = 0; y<input.getHeight()-2; y++) {
				// Edge processing
				Color color = new Color((int)distBox(new Color(input.getRGB(x,y)),new Color(input.getRGB(x+1,y)))/1, 
					(int)distBox(new Color(input.getRGB(x,y)),new Color(input.getRGB(x,y+1)))/1,
					(int)distBox(new Color(input.getRGB(x,y)),new Color(input.getRGB(x+1,y+1)))/1);				
				output.setRGB(x,y+1,color.getRGB());
			}
		}
		return output;
	}
	
	public static BufferedImage meanFilter (BufferedImage input) {
		//BufferedImage output = new BufferedImage(input.getWidth(), input.getHeight(), input.getType());
		ImageArray img = new ImageArray(input);
		BufferedImage output = img.toImage();
		for (int x = 0; x<input.getWidth()-3; x++) {
			for (int y = 0; y<input.getHeight()-3; y++) {
				int edge = new Color((img.array[x][y][1] + img.array[x+1][y][1] + img.array[x+2][y][1] +
					img.array[x][y+1][1] + 0*img.array[x+1][y+1][1] + img.array[x+2][y+1][1] +
					img.array[x][y+2][1] + img.array[x+1][y+2][1] + img.array[x+ 2][y+2][1])/8,
					(img.array[x][y][2] + img.array[x+1][y][2] + img.array[x+2][y][2] +
					img.array[x][y+1][2] + 0*img.array[x+1][y+1][2] + img.array[x+2][y+1][2] +
					img.array[x][y+2][2] + img.array[x+1][y+2][2] + img.array[x+ 2][y+2][2])/8,
					(img.array[x][y][3] + img.array[x+1][y][3] + img.array[x+2][y][3] +
					img.array[x][y+1][3] + 0*img.array[x+1][y+1][3] + img.array[x+2][y+1][3] +
					img.array[x][y+2][3] + img.array[x+1][y+2][3] + img.array[x+ 2][y+2][3])/8).getRGB();
				output.setRGB(x+1, y+1, edge);
			}
		}
		return output;
	}
	
	public static Mesh oMesh (BufferedImage input, int threshold) {
		//Mark each point by region : ideal constant density output map with matter points representing each region
		Mesh output = new Mesh();

		double maxVal = 0.1;
		int DONE = 0xFFFFFFFF;
		int height = input.getHeight(), width = input.getWidth();
		int pointIndex = 0;
		BufferedImage in = new BufferedImage(input.getWidth()+2, input.getHeight()+2, input.getType());
		for(int x = 0; x < in.getWidth(); x++) {
			for(int y = 0; y < in.getHeight(); y++) {
				in.setRGB(x, y, DONE);
			}
		}
		for(int x = 0; x < input.getWidth(); x++) {
			for(int y = 0; y < input.getHeight(); y++) {
				in.setRGB(x+1, y+1, input.getRGB(x,y));
			}
		}
		for (int x = 0; x<width; x++) {
			for (int y = 0; y<height; y++) {
				if(input.getRGB(x, y) != DONE) {
				output.startFace();
				int[] rdir = {0,-1};
				int[] bdir = {1,0};
				LinkedList points = new LinkedList();
				int a = x, b = y;
				int colorNum = 0;
				int turnct = 0;
					while(turnct < 5) {
						if(debug)
							System.out.println("" + a + " , " + b);
						if(rdir[0] == rdir[1] || bdir[0] == bdir[1]) throw new IllegalStateException();
						//if(a < height && a >= 0 && b < width && b >= 0 && img.getRGB(a+bdir[0], b+bdir[1]) != DONE)
						if(input.getRGB(a, b) != DONE)
							colorNum = in.getRGB(a+1,b+1);
						else {
							if(debug)
								System.out.println("Turning CCW to avoid array overflow");
							int rdtmp = rdir[0];
							rdir[0] = -rdir[1];
							rdir[1] = -rdtmp;
							int bdtmp = bdir[0];
							bdir[0] = -bdir[1];
							bdir[1] = -bdtmp;
							//System.out.println("Broken");
							turnct++;
							//continue;
							//break;
						}
							
						int[][] leftForward = {{a+rdir[0], b+rdir[1]},{a+bdir[0], b+bdir[1]}};
						Color color = new Color(colorNum);
						int red = color.getRed(), green = color.getGreen(), blue = color.getBlue();
						double[] colorArray = {red, green, blue};
						int right, bottom, corner;
						if(leftForward[0][1] < height && leftForward[0][1] >= 0 && leftForward[0][0] < width && leftForward[0][0] >= 0)
							right = in.getRGB(leftForward[0][0]+1, leftForward[0][1]+1);
						else
							right = DONE;
						double[] ra = {Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE};
						if(right != DONE) {
							Color rcol = new Color(right);
							double[] rd = {rcol.getRed(), rcol.getGreen(), rcol.getBlue()};
							ra = rd;
						}
						double rdist = distance(colorArray, ra);
						
						// Move right if path is clear
						if(rdist < threshold && input.getRGB(leftForward[0][0], leftForward[0][1]) != DONE) { // ? 
							if(debug)
								System.out.println("Moving right " + leftForward[0][0] + ", " + leftForward[0][1] + " : " + rdir[0] + " , " + rdir[1] + " | rdist: " + rdist);
							a = leftForward[0][0];
							b = leftForward[0][1];
						}
						else {
							if(leftForward[1][1] < height && leftForward[1][1] >= 0 && leftForward[1][0] < width && leftForward[1][0] >= 0)
								bottom = in.getRGB(leftForward[1][0]+1, leftForward[1][1]+1);
							else
								bottom = DONE;
							int[] rc = {a+rdir[0]+bdir[0], b+rdir[1]+bdir[1]}; 
							if(rc[1] < height && rc[1] >= 0 && rc[0] < width && rc[0] >= 0)
								corner = in.getRGB(rc[0]+1, rc[1]+1);
							else
								corner = DONE;
							double[] ba = {Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE};
							double[] ca = {Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE};
							if(bottom != DONE) {
								Color bcol = new Color(bottom);
								double[] bd = {bcol.getRed(), bcol.getGreen(), bcol.getBlue()};
								ba = bd;		
							}
							if(corner != DONE) {
								Color ccol = new Color(bottom);
								double[] cd = {ccol.getRed(), ccol.getGreen(), ccol.getBlue()};
								ca = cd;		
							}
							double bdist = distance(colorArray, ba);
							double cdist = distance(colorArray, ca);
							
							//Right point is valid high contrast edge
							
							double[] pt = {a+rdir[0]/2,-(b+rdir[1]/2),0};
							if(!output.addToFace(pt)) break;
							try {
							input.setRGB(a+rdir[0], b+rdir[1], DONE);
							}
							catch(ArrayIndexOutOfBoundsException e) {}
							
							if(debug)
								System.out.println("Added point right");
							if(right != DONE)
								input.setRGB(leftForward[0][0], leftForward[0][1], DONE);
							// .X    |   <
							// X   <-|    v
							// Cornered; turn CCW
							if(bdist > threshold) {
								if(debug)
									System.out.println("Turning CCW: " + rdir[0] + " , " + rdir[1] + " | bdist: " + bdist);
						
								//Bottom point is valid high contrast edge
								double[] ptb = {a+bdir[0]/2,-(b+bdir[1]/2),0};
								if(!output.addToFace(ptb)) break; 
								try {
								input.setRGB(a+bdir[0], b+bdir[1], DONE);
								}
								catch(ArrayIndexOutOfBoundsException e) {}
								if(debug)
									System.out.println("Added point below");
								
								// - is ccw, + cw
								int rdtmp = rdir[0];
								rdir[0] = -rdir[1];
								rdir[1] = -rdtmp;
								int bdtmp = bdir[0];
								bdir[0] = -bdir[1];
								bdir[1] = -bdtmp;
								
								
								if(bottom != DONE)
									input.setRGB(leftForward[1][0], leftForward[1][1], DONE);
	
							}
							// Concave edge; turn CW
							else if(cdist > threshold) {
								if(debug)
									System.out.println("Turning CW, " + rdir[0] + " , " + rdir[1]);
								//a = rc[0];
								//b = rc[1];
								int rdtmp = rdir[0];
								rdir[0] = rdir[1];
								rdir[1] = rdtmp;
								int bdtmp = bdir[0];
								bdir[0] = bdir[1];
								bdir[1] = bdtmp;
							}
							// Continuous right edge; drop down
							else if (input.getRGB(a+bdir[0], b+bdir[1]) != DONE){
								if(debug)
									System.out.println("Moving down " + bdir[0] + ", " + bdir[1]);
								a += bdir[0];
								b += bdir[1];
							}
							else {
								if(debug)System.out.println("Breaking");
								break;
							}
						}
						input.setRGB(a, b, DONE);
						if(a == x && b == y) break;
					}
					int size = points.size();
					int[] indices = new int[size];
					for(int i = 0; i < size; i++) {
						indices[i] = pointIndex+i;
					}
					if(debug)
						System.out.println("Closed face");
					//output.addFace(indices);
					output.endFace();
					pointIndex += points.size();
				}
				input.setRGB(x, y, DONE);
			}
		}
		return output;
	}

	public static Mesh bMesh (BufferedImage input, int threshold) {
		Mesh mesh = new Mesh(threshold);
		double maxVal = 0.1;
		int DONE = 0xFFFFFFFF;
		int height = input.getHeight(), width = input.getWidth();
		//destroys input image!
		//Copy image with a high-contrast border
		BufferedImage in = new BufferedImage(input.getWidth()+2, input.getHeight()+2, input.getType());
		for(int x = 0; x < width+2; x++) {
			in.setRGB(x, 0, DONE);
			in.setRGB(x, height-1, DONE);
		}
		for(int y = 0; y < height+2; y++) {
			in.setRGB(0, y, DONE);
			in.setRGB(width-1, y, DONE);
		}
		for(int x = 0; x < width; x++)
			for(int y = 0; y < height; y++)
				in.setRGB(x+1, y+1, input.getRGB(x,y));

		for (int x = 0; x<width; x++) {
			for (int y = 0; y<height; y++) {
				if(input.getRGB(x, y) != DONE) {
				int a = x, b = y;
				int[] left = {0,-1}; //^
				int[] forward = {1,0}; //>
				
				//Inside loop for edge detection, outside for regionalization
				int colorNum = input.getRGB(a, b);
				Color color = new Color(colorNum);
				int red = color.getRed(), green = color.getGreen(), blue = color.getBlue();
				double[] colorArray = {red, green, blue};
				//-----------------------------------------------------------
				
				//double lastContrast = 0;
				
				mesh.startFace();
				int onStartingSpot = 0;
				int la = a, lb = b; 
					while(onStartingSpot < 5) {
						System.out.println(input.getRGB(a, b) + " " + a + " " + b);
						//If eye remains on same spot or returns, terminate // Return is obsolete!
						if(la == a && lb == b)
							onStartingSpot++;
						else
							onStartingSpot = 0;
						la = a;
						lb = b;
						
						//if(debug)
							System.out.println("" + a + " , " + b + " Repeat: " + onStartingSpot); 
						
						int[][] leftForward = {{a+left[0], b+left[1]},{a+forward[0], b+forward[1]}};
						int leftColor, forwardColor;
						
						//Get color contrast on left side
						if(leftForward[0][1] < height && leftForward[0][1] >= 0 && leftForward[0][0] < width && leftForward[0][0] >= 0)
							leftColor = input.getRGB(leftForward[0][0], leftForward[0][1]);
						else
							leftColor = DONE;
						double leftContrast = Double.MAX_VALUE;
						if(leftColor != DONE) {
							double[] leftArray;
							Color lcol = new Color(leftColor);
							double[] tempArray = {lcol.getRed(), lcol.getGreen(), lcol.getBlue()};
							leftArray = tempArray;
							leftContrast = distance(colorArray, leftArray);
						}
						//if(leftContrast != lastContrast) {
						//	lastContrast = leftContrast;
							//System.out.println("Contrast: " + lastContrast);
						//}
						
						//--------------------------------
						
						//1st case: left is low contrast and is not formerly occupied: rotate CCW and move to new forward
						if(leftContrast < threshold) {
							if(debug)
								System.out.println("Rotating CCW: " + leftForward[0][0] + ", " + leftForward[0][1] + " : " + left[0] + " , " + left[1] + " | Contrast: " + leftContrast);
							//Rotate CCW
							forward[0] = left[0];
							forward[1] = left[1];
							if(left[1] == 0) {
								left[0] = -forward[1];
								left[1] = -forward[0];
							}
							else {
								left[0] = forward[1];
								left[1] = forward[0];
							}
								
							
							a += forward[0];
							b += forward[1];
						}
						else {
							if(leftColor != DONE) {
								input.setRGB(leftForward[0][0], leftForward[0][1], DONE);
								//Left point is valid high contrast edge
								if(debug)
									System.out.println("Added point left");
								double[] pt = {a+left[0]/2,-(b+left[1]/2),0};
								if(!mesh.addToFace(pt)) break;
								try {
								input.setRGB(a+left[0], b+left[1], DONE);
								}
								catch(ArrayIndexOutOfBoundsException e) {System.err.println("OUT OF BOUNDS: " + (a+left[0]) + " , " + (b+left[1]));}
								//--------------------------------------
							}
							
							//Get forward color contrast
							if(leftForward[1][1] < height && leftForward[1][1] >= 0 && leftForward[1][0] < width && leftForward[1][0] >= 0)
								forwardColor = input.getRGB(leftForward[1][0], leftForward[1][1]);
							else
								forwardColor = DONE;
							double forwardContrast = Double.MAX_VALUE;
							if(forwardColor != DONE) {
								double[] forwardArray;
								Color fcol = new Color(forwardColor);
								double[] tempArray = {fcol.getRed(), fcol.getGreen(), fcol.getBlue()};
								forwardArray = tempArray;
								forwardContrast = distance(colorArray, forwardArray);
							}
							//--------------------------
								
							//Forward is clear; move forward
							if(forwardContrast < threshold) {
								if(debug)
									System.out.println("Moving forward: " + forward[0] + " , " + forward[1] + " | Contrast: " + forwardContrast);
								a += forward[0];
								b += forward[1];
							}
							//------------------------------
							
							//Forward is blocked: Turn CW
							else {
								if(debug)
									System.out.println("Turning CW: " + left[0] + " , " + left[1] + " | Contrast: " + forwardContrast);
								left[0] = forward[0];
								left[1] = forward[1];
								if(left[0] == 0) {
									forward[0] = -left[1];
									forward[1] = -left[0];
								}
								else {
									forward[0] = left[1];
									forward[1] = left[0];
								}
							}
							}
						//if(a != x || b != y)
							input.setRGB(a, b, DONE);
						}
						if(debug)
							System.out.println("Ending face");
						mesh.endFace();
					}
					input.setRGB(x, y, DONE);
				}
			}
			return mesh;
		}

	public static Mesh toField (BufferedImage input, int threshold) {
		ImageArray image = new ImageArray(input);
		int[][][] in = image.array;
		Mesh mesh = new Mesh(15);
		double maxVal = 0.1;
		int DONE = 0x0FFFFFF;
		int height = input.getHeight(), width = input.getWidth();

		for (int x = 0; x<width; x++) {
			for (int y = 0; y<height; y++) {
				if(in[x][y][0] != DONE) {
				int a = x, b = y;
				int[] left = {0,-1};
				int[] forward = {1,0};
				
				mesh.startFace();
				int onStartingSpot = 0;
				int la = a, lb = b; 
					while(onStartingSpot < 5) {
						System.out.println(in[a][b][0] + ": " + a + " , " + b + " | Repeat: " + onStartingSpot);
						//If eye remains on same spot 5x, terminate
						if(la == a && lb == b)
							onStartingSpot++;
						else
							onStartingSpot = 0;
						la = a;
						lb = b;
						
						int[][] leftForward = {{a+left[0], b+left[1]},{a+forward[0], b+forward[1]}};
						int leftColor, forwardColor;
						
						//Get color contrast on left side
						if(leftForward[0][1] < height && leftForward[0][1] >= 0 && leftForward[0][0] < width && leftForward[0][0] >= 0)
							leftColor = in[leftForward[0][0]][leftForward[0][1]][0];
						else
							leftColor = DONE;
						double leftContrast = Double.MAX_VALUE;
						if(leftColor != DONE) {
							double[] leftArray;
							Color lcol = new Color(leftColor);
							double[] tempArray = {lcol.getRed(), lcol.getGreen(), lcol.getBlue()};
							leftArray = tempArray;
							leftContrast = distance(in[a][b], in[leftForward[0][0]][leftForward[0][1]]);
						}
						//--------------------------------
						
						//1st case: left is low contrast and is not formerly occupied: rotate CCW and move to new forward
						if(leftContrast < threshold) {
							if(debug)
								System.out.println("Rotating CCW: " + leftForward[0][0] + ", " + leftForward[0][1] + " : " + left[0] + " , " + left[1] + " | Contrast: " + leftContrast);
							//Rotate CCW
							forward[0] = left[0];
							forward[1] = left[1];
							if(left[1] == 0) {
								left[0] = -forward[1];
								left[1] = -forward[0];
							}
							else {
								left[0] = forward[1];
								left[1] = forward[0];
							}
								
							
							a += forward[0];
							b += forward[1];
						}
						else {
							if(leftColor != DONE && in[a+left[0]][b+left[1]][0] != DONE) {
								//in[leftForward[0][0]][leftForward[0][1]][0] =  DONE;
								
								//Left point is valid high contrast edge
								if(debug)
									System.out.println("Added point left");
								double[] pt = {a+left[0]/2,-(b+left[1]/2),0};
								if(!mesh.addToFace(pt)) break;
								try {
								in[a+left[0]][b+left[1]][0] = DONE;
								}
								catch(ArrayIndexOutOfBoundsException e) {System.err.println("OUT OF BOUNDS: " + (a+left[0]) + " , " + (b+left[1]));}
								//--------------------------------------
							}
							
							//Get forward color contrast
							if(leftForward[1][1] < height && leftForward[1][1] >= 0 && leftForward[1][0] < width && leftForward[1][0] >= 0)
								forwardColor = in[leftForward[1][0]][leftForward[1][1]][0];
							else
								forwardColor = DONE;
							double forwardContrast = Double.MAX_VALUE;
							if(forwardColor != DONE) {
								double[] forwardArray;
								Color fcol = new Color(forwardColor);
								double[] tempArray = {fcol.getRed(), fcol.getGreen(), fcol.getBlue()};
								forwardArray = tempArray;
								forwardContrast = distance(in[a][b], in[leftForward[1][0]][leftForward[1][1]]);
							}
							//--------------------------
								
							//Forward is clear; move forward
							if(forwardContrast < threshold) {
								if(debug)
									System.out.println("Moving forward: " + forward[0] + " , " + forward[1] + " | Contrast: " + forwardContrast);
								a += forward[0];
								b += forward[1];
							}
							//------------------------------
							
							//Forward is blocked: Turn CW
							else {
								if(debug)
									System.out.println("Turning CW: " + left[0] + " , " + left[1] + " | Contrast: " + forwardContrast);
								left[0] = forward[0];
								left[1] = forward[1];
								if(left[0] == 0) {
									forward[0] = -left[1];
									forward[1] = -left[0];
								}
								else {
									forward[0] = left[1];
									forward[1] = left[0];
								}
							}
							}
						//if(a != x || b != y)
							//input.setRGB(a, b, DONE);
						in[a][b][0] = DONE;
						}
						if(debug)
							System.out.println("Ending face");
						mesh.endFace();
					}
					//input.setRGB(x, y, DONE);
				in[x][y][0] = DONE;
				}
			}
			return mesh;
		}
	
	public static Mesh toMeshWorks (BufferedImage input, int threshold) {
		ImageArray image = new ImageArray(input);
		int[][][] in = image.array;
		Mesh mesh = new Mesh(Math.PI / 8);
		int DONE = 0x0FFFFFFF;
		int height = input.getHeight(), width = input.getWidth();

		for (int x = 0; x<width; x++) {
			for (int y = 0; y<height; y++) {
				if(in[x][y][0] != DONE) {
					int a = x, b = y;
					int[] left = {0,-1};
					int[] forward = {1,0};
					int onStartingSpot = 0;
					int la = a, lb = b;
					mesh.startFace();
					
					while(onStartingSpot < 5) {
						if(debug)
							System.out.println(in[a][b][0] + ": " + a + " , " + b + " | Repeat: " + onStartingSpot);
						//If eye remains on same spot 5x, terminate
						if(a == x && b == y) 
							if(la == a && lb == b)
								onStartingSpot++;
							else
								onStartingSpot+=5;
						la = a;
						lb = b;
						
						int[][] leftForward = {{a+left[0], b+left[1]},{a+forward[0], b+forward[1]}};
						//Get color contrast on left side
						double leftContrast = DONE;
						if(leftForward[0][1] < height && leftForward[0][1] >= 0 && leftForward[0][0] < width && leftForward[0][0] >= 0)
							leftContrast = ImageArray.colorDistance(in[a][b], in[leftForward[0][0]][leftForward[0][1]]);
						
						//1st case: left is low contrast and is not formerly occupied: rotate CCW and move to new forward
						if(leftContrast < threshold) {
							if(debug)
								System.out.println("Rotating CCW: " + leftForward[0][0] + ", " + leftForward[0][1] + " : " + left[0] + " , " + left[1] + " | Contrast: " + leftContrast);
							//Rotate CCW
							forward[0] = left[0];
							forward[1] = left[1];
							if(left[1] == 0) {
								left[0] = -forward[1];
								left[1] = -forward[0];
							}
							else {
								left[0] = forward[1];
								left[1] = forward[0];
							}
							a += forward[0];
							b += forward[1];
						}
						else {
							//Left point is valid high contrast edge
							try {
							in[leftForward[0][0]][leftForward[0][1]][0] =  DONE;
							}
							catch(Exception e) {}
							if(debug)
								System.out.println("Added point left");
							double[] pt = {a+left[0]/2,-(b+left[1]/2),0};
							if(!mesh.addToFace(pt)) break;
							
							//Get forward color contrast
							double forwardContrast = DONE;
							if(leftForward[1][1] < height && leftForward[1][1] >= 0 && leftForward[1][0] < width && leftForward[1][0] >= 0)
								forwardContrast = ImageArray.colorDistance(in[a][b], in[leftForward[1][0]][leftForward[1][1]]);
								
							//Forward is clear; move forward
							if(forwardContrast < threshold) {
							if(debug)
								System.out.println("Moving forward: " + forward[0] + " , " + forward[1] + " | Contrast: " + forwardContrast);
							a += forward[0];
							b += forward[1];
						}
						//------------------------------
						
						//Forward is blocked: Turn CW
						else {
							if(debug)
								System.out.println("Turning CW: " + left[0] + " , " + left[1] + " | Contrast: " + forwardContrast);
							left[0] = forward[0];
							left[1] = forward[1];
							if(left[0] == 0) {
								forward[0] = -left[1];
								forward[1] = -left[0];
							}
							else {
								forward[0] = left[1];
								forward[1] = left[0];
							}
						}
						}
					in[a][b][0] = DONE;
					}
					if(debug)
						System.out.println("Ending face");
					mesh.endFace();
				}
				in[x][y][0] = DONE;
			}
		}
		return mesh;
	}

	public static Mesh toMeshWorketh (BufferedImage input, int threshold) {
		//Automatic non-maximal suppression
		ImageArray image = new ImageArray(input);
		int[][][] in = image.array;
		Mesh mesh = new Mesh();
		int DONE = 0x0FFFFFFF;
		int height = input.getHeight(), width = input.getWidth();

		for (int x = 0; x<width; x++) {
			for (int y = 0; y<height; y++) {
				if(in[x][y][0] != DONE) {
					int a = x, b = y;
					int[] left = {0,-1};
					int[] forward = {1,0};
					int onStartingSpot = 0;
					int la = a, lb = b;
					mesh.startFace();
					
					while(onStartingSpot < 5) {
						//If eye remains on same spot 5x, terminate
						if(a == x && b == y) 
							if(la == a && lb == b)
								onStartingSpot++;
							else
								onStartingSpot+=5;
						la = a;
						lb = b;
						
						int[][] leftForward = {{a+left[0], b+left[1]},{a+forward[0], b+forward[1]}};
						//Get color contrast on left side
						double leftContrast = DONE;
						if(leftForward[0][1] < height && leftForward[0][1] >= 0 && leftForward[0][0] < width && leftForward[0][0] >= 0)
							leftContrast = ImageArray.colorDistance(in[a][b], in[leftForward[0][0]][leftForward[0][1]]);
						
						//1st case: left is low contrast and is not formerly occupied: rotate CCW and move to new forward
						if(leftContrast < threshold) {
							//Rotate CCW
							forward[0] = left[0];
							forward[1] = left[1];
							if(left[1] == 0) {
								left[0] = -forward[1];
								left[1] = -forward[0];
							}
							else {
								left[0] = forward[1];
								left[1] = forward[0];
							}
							a += forward[0];
							b += forward[1];
						}
						else {
							//Left point is valid high contrast edge
							try {
							in[leftForward[0][0]][leftForward[0][1]][0] =  DONE;
							}
							catch(Exception e) {}
							double[] pt = {a+left[0]/2,-(b+left[1]/2),0};
							if(!mesh.addToFace(pt)) break;
							
							//Get forward color contrast
							double forwardContrast = DONE;
							if(leftForward[1][1] < height && leftForward[1][1] >= 0 && leftForward[1][0] < width && leftForward[1][0] >= 0)
								forwardContrast = ImageArray.colorDistance(in[a][b], in[leftForward[1][0]][leftForward[1][1]]);
								
							//Forward is clear; move forward
							if(forwardContrast < threshold) {
							a += forward[0];
							b += forward[1];
						}
						//------------------------------
						
						//Forward is blocked: Turn CW
						else {
							left[0] = forward[0];
							left[1] = forward[1];
							if(left[0] == 0) {
								forward[0] = -left[1];
								forward[1] = -left[0];
							}
							else {
								forward[0] = left[1];
								forward[1] = left[0];
							}
						}
						}
					in[a][b][0] = DONE;
					}
					mesh.endFace();
				}
				in[x][y][0] = DONE;
			}
		}
		//mesh = mesh.simplifyEdges(3);
		return mesh;
	}

	//Scale contrast by 1/2 because it comes in pairs!
	public static Mesh toMesh (BufferedImage input, int threshold) {
		//Automatic non-maximal suppression
		ImageArray image = new ImageArray(input);
		int[][][] in = image.array;
		Mesh mesh = new Mesh();
		int DONE = 0x0FFFFFFF;
		int height = input.getHeight(), width = input.getWidth();

		for (int x = 0; x<width; x++) {
			for (int y = 0; y<height; y++) {
				if(in[x][y][0] != DONE) {
					int a = x, b = y;
					int[] left = {0,-1};
					int[] forward = {1,0};
					int onStartingSpot = 0;
					int la = a, lb = b;
					mesh.startFace();
					
					while(onStartingSpot < 5) {
						//If eye remains on same spot 5x, terminate
						if(a == x && b == y) 
							if(la == a && lb == b)
								onStartingSpot++;
							else
								onStartingSpot+=5;
						la = a;
						lb = b;
						
						int[][] leftForward = {{a+left[0], b+left[1]},{a+forward[0], b+forward[1]}};
						//Get color contrast on left side
						double leftContrast = DONE;
						if(leftForward[0][1] < height && leftForward[0][1] >= 0 && leftForward[0][0] < width && leftForward[0][0] >= 0)
							leftContrast = ImageArray.colorDistance(in[a][b], in[leftForward[0][0]][leftForward[0][1]]);
						
						//1st case: left is low contrast and is not formerly occupied: rotate CCW and move to new forward
						if(leftContrast < threshold) {
							//Rotate CCW
							forward[0] = left[0];
							forward[1] = left[1];
							if(left[1] == 0) {
								left[0] = -forward[1];
								left[1] = -forward[0];
							}
							else {
								left[0] = forward[1];
								left[1] = forward[0];
							}
							a += forward[0];
							b += forward[1];
						}
						else {
							//Left point is valid high contrast edge
							try {
							in[leftForward[0][0]][leftForward[0][1]][0] =  DONE;
							}
							catch(Exception e) {}
							double[] pt = {a+left[0]/2,-(b+left[1]/2),0};
							if(!mesh.addToFace(pt)) break;
							
							//Get forward color contrast
							double forwardContrast = DONE;
							if(leftForward[1][1] < height && leftForward[1][1] >= 0 && leftForward[1][0] < width && leftForward[1][0] >= 0)
								forwardContrast = ImageArray.colorDistance(in[a][b], in[leftForward[1][0]][leftForward[1][1]]);
								
							//Forward is clear; move forward
							if(forwardContrast < threshold) {
							a += forward[0];
							b += forward[1];
						}
						//------------------------------
						
						//Forward is blocked: Turn CW
						else {
							left[0] = forward[0];
							left[1] = forward[1];
							if(left[0] == 0) {
								forward[0] = -left[1];
								forward[1] = -left[0];
							}
							else {
								forward[0] = left[1];
								forward[1] = left[0];
							}
						}
						}
					in[a][b][0] = DONE;
					}
					mesh.endFace();
				}
				in[x][y][0] = DONE;
			}
		}

		mesh = mesh.simplifyEdges(1);  //TODO: Does not completely work... Aw....
		//mesh.cleanUnusedPoints();
		System.out.println("PI");
		return mesh;
	}

	public static Mesh toMesh3 (BufferedImage input, int threshold) {
		//Automatic non-maximal suppression
		ImageArray image = new ImageArray(input);
		int[][][] in = image.array;
		Mesh mesh = new Mesh();
		int DONE = 0x0FFFFFFF;
		int height = input.getHeight(), width = input.getWidth();

		for (int x = 0; x<width; x++) {
			for (int y = 0; y<height; y++) {
				if(in[x][y][0] != DONE) {
					int a = x, b = y;
					int[] left = {0,-1};
					int[] forward = {1,0};
					int onStartingSpot = 0;
					int la = a, lb = b;
					mesh.startFace();
					
					while(onStartingSpot < 5) {
						//If eye remains on same spot 5x, terminate
						if(a == x && b == y) 
							if(la == a && lb == b)
								onStartingSpot++;
							else
								onStartingSpot+=5;
						la = a;
						lb = b;
						
						int[][] leftForward = {{a+left[0], b+left[1]},{a+forward[0], b+forward[1]}};
						//Get color contrast on left side
						double leftContrast = DONE;
						if(leftForward[0][1] < height && leftForward[0][1] >= 0 && leftForward[0][0] < width && leftForward[0][0] >= 0)
							leftContrast = ImageArray.colorDistance(in[a][b], in[leftForward[0][0]][leftForward[0][1]]);
						
						//1st case: left is low contrast and is not formerly occupied: rotate CCW and move to new forward
						if(leftContrast < threshold) {
							//Rotate CCW
							forward[0] = left[0];
							forward[1] = left[1];
							if(left[1] == 0) {
								left[0] = -forward[1];
								left[1] = -forward[0];
							}
							else {
								left[0] = forward[1];
								left[1] = forward[0];
							}
							a += forward[0];
							b += forward[1];
						}
						else {
							//Left point is valid high contrast edge
							try {
							in[leftForward[0][0]][leftForward[0][1]][0] =  DONE;
							}
							catch(Exception e) {}
							double[] pt = {a+left[0]/2,-(b+left[1]/2),0};
							if(!mesh.addToFace(pt)) break;
							
							//Get forward color contrast
							double forwardContrast = DONE;
							if(leftForward[1][1] < height && leftForward[1][1] >= 0 && leftForward[1][0] < width && leftForward[1][0] >= 0)
								forwardContrast = ImageArray.colorDistance(in[a][b], in[leftForward[1][0]][leftForward[1][1]]);
								
							//Forward is clear; move forward
							if(forwardContrast < threshold) {
							a += forward[0];
							b += forward[1];
						}
						//------------------------------
						
						//Forward is blocked: Turn CW
						else {
							left[0] = forward[0];
							left[1] = forward[1];
							if(left[0] == 0) {
								forward[0] = -left[1];
								forward[1] = -left[0];
							}
							else {
								forward[0] = left[1];
								forward[1] = left[0];
							}
						}
						}
					in[a][b][0] = DONE;
					}
					mesh.endFace();
				}
				in[x][y][0] = DONE;
			}
		}
		//mesh = mesh.simplifyEdges(1);
		return mesh;
	}

	
	public static Mesh toMesh2 (BufferedImage input, int threshold) {
		//Automatic non-maximal suppression
		ImageArray image = new ImageArray(input);
		int[][][] in = image.array;
		Mesh mesh = new Mesh(10);
		int DONE = 0x0FFFFFFF;
		int height = input.getHeight(), width = input.getWidth();

		for (int x = 0; x<width; x++) {
			for (int y = 0; y<height; y++) {
				if(in[x][y][0] != DONE) {
					int a = x, b = y;
					int[] left = {0,-1};
					int[] forward = {1,0};
					int onStartingSpot = 0;
					int la = a, lb = b;
					mesh.startFace();
					
					while(onStartingSpot < 5) {
						//If eye remains on same spot 5x, terminate
						if(a == x && b == y) 
							if(la == a && lb == b)
								onStartingSpot++;
							else
								onStartingSpot+=5;
						la = a;
						lb = b;
						
						int[][] leftForward = {{a+left[0], b+left[1]},{a+forward[0], b+forward[1]}};
						//Get color contrast on left side
						double leftContrast = DONE;
						if(leftForward[0][1] < height && leftForward[0][1] >= 0 && leftForward[0][0] < width && leftForward[0][0] >= 0)
							leftContrast = ImageArray.colorDistance(in[a][b], in[leftForward[0][0]][leftForward[0][1]]);
						
						//1st case: left is low contrast and is not formerly occupied: rotate CCW and move to new forward
						if(leftContrast < threshold) {
							
							//Rotate CCW
							forward[0] = left[0];
							forward[1] = left[1];
							if(left[1] == 0) {
								left[0] = -forward[1];
								left[1] = -forward[0];
							}
							else {
								left[0] = forward[1];
								left[1] = forward[0];
							}
							a += forward[0];
							b += forward[1];
						}
						else {
							// NMS Module
							 /*
							double leftContrast2 = -DONE;
							while(leftContrast2 < leftContrast) {
								if(b + left[1]*2 < height && b + left[1]*2 >= 0 && a + left[0]*2 < width && a + left[0]*2 >= 0 && in[a+left[0]*2][b+left[1]*2][0] != DONE) {
									leftContrast2 = ImageArray.colorDistance(in[a][b], in[leftForward[0][0]+left[0]][leftForward[0][1]+left[1]]);
									if(leftContrast2 > leftContrast) {
										try {
											in[a][b][0] =  DONE;
											}
										catch(Exception e) {}
										System.out.println("Falling left...");
										a += left[0];
										b += left[1];
										leftContrast2 = leftContrast;
									}
									else break;
								}
								else break;
							}
							 */
							// END NMS
							
							//Left point is valid high contrast edge
							try {
							in[leftForward[0][0]][leftForward[0][1]][0] =  DONE;
							}
							catch(Exception e) {}
							double[] pt = {a+left[0]/2,-(b+left[1]/2),0};
							if(!mesh.addToFace(pt)) break;
							
							//Get forward color contrast
							double forwardContrast = DONE;
							if(leftForward[1][1] < height && leftForward[1][1] >= 0 && leftForward[1][0] < width && leftForward[1][0] >= 0)
								forwardContrast = ImageArray.colorDistance(in[a][b], in[leftForward[1][0]][leftForward[1][1]]);
								
							//Forward is clear; move forward
							if(forwardContrast < threshold) {
								a += forward[0];
								b += forward[1];
							}
						//------------------------------
						
						//Forward is blocked: Turn CW
						else {
							left[0] = forward[0];
							left[1] = forward[1];
							if(left[0] == 0) {
								forward[0] = -left[1];
								forward[1] = -left[0];
							}
							else {
								forward[0] = left[1];
								forward[1] = left[0];
							}
						}
						}
					in[a][b][0] = DONE;
					}
					mesh.endFace();
				}
				in[x][y][0] = DONE;
			}
		}
		//mesh = mesh.simplifyEdges(1);
		return mesh;
	}
	
	public static Mesh getUniquePoints(BufferedImage image, int threshold) {
		Mesh mesh = new Mesh();
		int width = image.getWidth(), height = image.getHeight();
		BufferedImage contrast = threshold(suppress(sobelColor(image)), 200);
		//NM-suppress adjacent contrasts
		//Points need to be remarkable vertices, NEVER interiors and NEVER edges
		
		mesh = toMesh(suppress(edge3(image)),threshold);
		/*for(int x = 0; x < width - 2; x+=2) {
			for(int y = 0; y < height - 2; y+=2) {
				if(contrast.getRGB(x,y) == Color.black.getRGB()) continue;
				
				//System.out.println(contrast.getRGB(x, y));
				double[] coords = {x,y};
				mesh.addPoint(coords);
			}
		}*/
		System.out.println(mesh.getPoints().size() + " points added.");
		return mesh;
	}
	
	public static Mesh reversePerspective(BufferedImage image1, BufferedImage image2, int threshold) {
		Mesh mesh = new Mesh();
		System.out.println("Gathering unique points...");
		Mesh u1 = getUniquePoints(image1, threshold), u2 = getUniquePoints(image2, threshold);
		
		ArrayList<double[]> points1 = u1.getPoints();
		ArrayList<double[]> points2 = u2.getPoints();
		for(int i = 0; i < points1.size(); i++) {
			System.out.println("Searching for closest matching points at index " + i + " of " + points1.size());
			double[] findPoint = points1.get(i);
			int[] coords;
			if(!(findPoint[0] >=0 && findPoint[0] < image1.getWidth() && findPoint[1] >=0 && findPoint[1] < image1.getHeight()))
				coords = Image.findClosestPoint(image1, image2, (int)findPoint[0], (int)findPoint[1], 2);
			else continue;
			double[] c = {coords[0], coords[1], 0};
			mesh.startFace();
			mesh.addToFace(c);
			//if(coords[2] > threshold) continue;
			//System.out.println(coords[0] + "," + coords[1] + "," + coords[2]);
			//System.out.println(c[0] + "," + c[1] + "," + c[2]);
			double delta = math.Math3D.distance(c, findPoint);
			double far = image1.getWidth() + image1.getHeight() /2;
			c[2] = far / delta*50;
			//if(points2.contains(c)) {
			if(delta > 1.7)
			mesh.addToFace(findPoint);
			mesh.endFace();
			//points2.remove(c);
			//System.out.println("Added a point to the object!");
			//}
			//else System.out.println("No matching point.");
		}
		System.out.println("Points in A not B: " + points1.size() + ", B not A: " + points2.size());
		return mesh;
	}

	public static Mesh plasticWrap(BufferedImage input) {
		// Line-sweeps the image for unique vertices, outputs a complete empirical mesh
		BufferedImage contrast = sobelColor(input);
		Mesh mesh = new Mesh();
		int width = input.getWidth();
		int height = input.getHeight();
		// Commence line sweep
		for(int x = 0; x < width; x++) {
			for(int y = 0; y < height; y++) {
				
			}
		}
		return mesh;
	}
	
	public static double distance(double[] l1, double[] l2) {
		int len = l1.length > l2.length ? l2.length : l1.length;
		double dist = 0;
		for (int i = 0; i < len; i++) {
			dist += Math.pow(l1[i] - l2[i],2);
		}
		dist = Math.sqrt(dist);
		return dist;
	}

	public static Mesh traceVectors (BufferedImage input, int threshold) {
		Mesh mesh = new Mesh();
		ImageArray ctr = new ImageArray(suppress(sobelColor(input)));
		ImageArray img = new ImageArray(input);
		for (int x = 0; x<input.getWidth()-1; x++) {
			for (int y = 0; y<input.getHeight()-1; y++) {
				double contrast = colorDist(ctr.getRGB(x,y));
				if(contrast > threshold) {
					mesh.startFace();
					int a = x, b = y;
					while(true) {
						int[] close = closest(ctr,a,b,1);
						//int[] high = highest(ctr,a,b,1);
						if (!(close[0] == 0 && close[1] == 0) && img.array[a+close[0]][b+close[1]][1] > -1) {
							contrast = colorDist(ctr.getRGB(a+close[0],b+close[1]));
							if(contrast >= threshold) {// || close[2] < 255-threshold) {
								double[] c = {a,-b,0};
								mesh.addToFace(c);
								a += close[0];
								b += close[1];
								if(a == x && b == y) mesh.endFace();
								img.array[a][b][1] = -1;
							}
							else {
								mesh.endFace();
								break;
							}
						}
						else {
							mesh.endFace();
							break;
						}
					}
					//img.array[x][y][1] = -2;
				}
				else {
				}
			}
		}
		return mesh;
	}
	
	//All I need is an NMS for vertices or one that doesn't leave holes in edges.
	//Unique point generator: NMS vertical & horizontal sweep; keep only points that occur in both sweeps!

	public static int[] closest(ImageArray img, int x, int y, int radius) {
		double close = 999999999;
		int[] dir = new int[3];
		dir[0] = 0; dir[1] = 0;
		// a/b precedence determines direction of smear flow!
		for(int b = -radius; b <= radius; b++) {
			for(int a = -radius; a <= radius; a++) {
				if(!(a==0 && b==0) && a+x >= 0 && b+y >= 0 && b+y < img.height && a+x < img.width) {
					if(img.array[x+a][y+b][1]>-1 && distance(new Color(img.array[x][y][0]), new Color(img.array[x+a][y+b][0])) < close) {
						dir[0] = a;
						dir[1] = b;
						close = distance(new Color(img.array[x][y][0]), new Color(img.array[x+a][y+b][0]));
					}
				}
			}
		}
		dir[2] = (int)close;
		return dir;
	}

	public static int[] highest(ImageArray img, int x, int y, int radius) {
		double close = 999999999;
		int[] dir = new int[3];
		dir[0] = 0; dir[1] = 0;
		for(int b = -radius; b <= radius; b++) {
			for(int a = -radius; a <= radius; a++) {
				if(!(a==0 && b==0) && a+x >= 0 && b+y >= 0 && b+y < img.height && a+x < img.width) {
					double dist = distance(new Color(0,0,0), new Color(img.array[x+a][y+b][0]));
					if(img.array[x+a][y+b][1]>-1 && dist > close) {
						dir[0] = a;
						dir[1] = b;
						close = dist;
					}
				}
			}
		}
		dir[2] = (int)close;
		return dir;
	}
	// Idea: use superclass for image modification template (i.e. bounds, operation, etc.
	
		public static BufferedImage regionalize2(BufferedImage input, int threshold) {
			BufferedImage output = new BufferedImage(input.getWidth(), input.getHeight(), input.getType());
			//ImageArray edge = new ImageArray(pathFinder(input));
			ImageArray img = new ImageArray(input);
			for (int x = 0; x<input.getWidth(); x++) {
				for (int y = 0; y<input.getHeight(); y++) {
					
					// Pass 1: calculate color average & flag pixels; calc bounding box
					if(img.array[x][y][1] > -1) {
						int[] color = new int[3];
						for(int i=0; i<3; i++)
							color[i] = img.array[x][y][i+1];
						Color original = new Color(img.array[x][y][0]);

						int[][] bbox = new int[2][2];
						for(int i=0; i<2; i++) {
							bbox[i][0] = x;
							bbox[i][1] = y;
						}
						
						img.array[x][y][1] = -1;
						int points = 1;
						int a = x, b = y;	
						int[] close = new int[3];
						close[0]=1;close[1]=1;close[2]=255;
						while(!(close[0] == 0 && close[1] == 0)) {
							close = closest(img, a,b,1);
							if(close[2] < threshold && distBox(original, new Color(img.array[a+close[0]][b+close[1]][0])) < threshold) {// && edge.array[a][b][1] < threshold) {
								a += close[0];
								b += close[1];
								for(int i=0; i<3; i++)
									color[i] += img.array[a][b][i+1];
								img.array[a][b][1] = -2;
								points++;
								
								if(a<bbox[0][0])
									bbox[0][0]=a;
								else if(a>bbox[1][0])
									bbox[1][0]=a;
								if(b<bbox[0][1])
									bbox[0][1]=b;
								else if(b>bbox[1][1])
									bbox[1][1]=b;
							}
							else
								break;
						}
						for(int i=0; i<3; i++) {
							color[i] /= points;
							if(color[i] < 0 || color[i] >255) {
								JOptionPane.showMessageDialog(null, ""+i+": "+color[i]);
							}
						}
						
						int average = new Color(color[0], color[1], color[2]).getRGB();
						// Pass 2: set all flagged colors to average
						for(a = bbox[0][0]; a <=bbox[1][0]; a++) {
							for(b = bbox[0][1]; b < bbox[1][1]; b++) {
								if(img.array[a][b][1] == -2) {
									img.array[a][b][0] = average;
									img.array[a][b][1] = -1;	
								}
							}
						}
						
						
					}
				}
			}
			output = img.toImage(img.array);
			return output;
		}
			
		public static BufferedImage regionalize (BufferedImage input, int threshold) {
			BufferedImage output = new BufferedImage(input.getWidth(), input.getHeight(), input.getType());
			ImageArray edge = new ImageArray(suppress(invert(edge3(input))));
			ImageArray img = new ImageArray(input);
			for (int x = 0; x<input.getWidth(); x++) {
				for (int y = 0; y<input.getHeight(); y++) {
					if(edge.array[x][y][0] != Color.black.getRGB()) {
						// Pass 1: calculate color average & flag pixels; calc bounding box
						if(img.array[x][y][1] > -1) {
							int[] color = new int[3];
							for(int i=0; i<3; i++)
								color[i] = img.array[x][y][i+1]; // Sets color for averaging
							Color original = new Color(img.array[x][y][0]); // Color of base pixel
							int[][] bbox = new int[2][2];
							for(int i=0; i<2; i++) {
								bbox[i][0] = x;
								bbox[i][1] = y;
							}
							img.array[x][y][1] = -1;
							int points = 1;
							int a = x, b = y;
							int[] close = new int[3]; close[0]=1;close[1]=1;close[2]=255;
							while(!(close[0] == 0 && close[1] == 0)) {
								close = closest(img,a,b,1);
								if(close[2] < threshold && distBox(original, new Color(img.array[a+close[0]][b+close[1]][0])) < threshold && edge.array[a][b][1] < threshold) {
									a += close[0];
									b += close[1];
									for(int i=0; i<3; i++)
										color[i] += img.array[a][b][i+1];
									img.array[a][b][1] = -2;
									points++;
									
									if(a<bbox[0][0])
										bbox[0][0]=a;
									else if(a>bbox[1][0])
										bbox[1][0]=a;
									if(b<bbox[0][1])
										bbox[0][1]=b;
									else if(b>bbox[1][1])
										bbox[1][1]=b;
								}
								else
									break;
							}
							for(int i=0; i<3; i++)
								color[i] /= points;
							int average = new Color(color[0], color[1], color[2]).getRGB();
							
							// Pass 2: set all flagged colors to average
							for(a = bbox[0][0]; a <=bbox[1][0]; a++) {
								for(b = bbox[0][1]; b < bbox[1][1]; b++) {
									if(img.array[a][b][1] == -2) {
										img.array[a][b][0] = average;
										img.array[a][b][1] = -1;	
									}
								}
							}
							
							
						}
					}
				}
			}
			output = img.toImage(img.array);
			return output;
		}
		
	// Returns a threshold of the image
	public static BufferedImage threshold (BufferedImage input, int threshold) {
		BufferedImage output = new BufferedImage(input.getWidth(), input.getHeight(), input.getType());
		for (int x = 0; x<input.getWidth()-1; x++) 
			for (int y = 0; y<input.getHeight()-1; y++) 
				if(sum(input.getRGB(x,y)) <threshold)
					output.setRGB(x,y,Color.black.getRGB());
				else
					output.setRGB(x,y,Color.white.getRGB());
		return output;
	} 
	
	public static BufferedImage toGray (BufferedImage input) {
		BufferedImage output = new BufferedImage(input.getWidth(), input.getHeight(), input.getType());
		for (int x = 0; x<input.getWidth(); x++)
			for (int y = 0; y<input.getHeight(); y++)
				output.setRGB(x, y, gray(input.getRGB(x,y)));
		return output;
	}
	
	public static BufferedImage copy (BufferedImage input) {
		BufferedImage output = new BufferedImage(input.getWidth(), input.getHeight(), input.getType());
		for (int x = 0; x<input.getWidth(); x++)
			for (int y = 0; y<input.getHeight(); y++)
				output.setRGB(x,y,input.getRGB(x, y));
		return output;
	}
	
	public static BufferedImage invert (BufferedImage input) {
		BufferedImage output = new BufferedImage(input.getWidth(), input.getHeight(), input.getType());
		for (int x = 0; x<input.getWidth(); x++)
			for (int y = 0; y<input.getHeight(); y++) {
				Color clr = new Color(input.getRGB(x,y));
				Color color = new Color(255-clr.getRed(), 255-clr.getGreen(), 255-clr. getBlue());
				output.setRGB(x,y,color.getRGB());
			}
		return output;
	}
	
	// Returns the sum of all of the color components (grayscale * 3)
	public static int sum (Color color) {
		return (color.getRed() + color. getGreen() + color.getBlue());
	}
	
	public static int sum (int color) {
		return sum(new Color(color));
	}
	
	// Returns the color as a grayscale
	public static int gray(Color color) {
		int average = sum(color)/3;
		return (new Color(average, average, average).getRGB());
	}

	public static int gray(int color) {
		int average = sum(new Color(color))/3;
		return (new Color(average, average, average)).getRGB();
	}
	
	// Finds the distance between two colors.
	public static double distance(Color color1, Color color2) {
		return Math.sqrt((Math.pow(color1.getRed()-color2.getRed(),2) 
				+ Math.pow(color1.getGreen()- color2.getGreen(),2) + Math.pow(color1.getBlue() - color2.getBlue(),2))/3);
	}
	
	public static double distance(int[] color1, int[] color2) {
		if(color1.length != color2.length)
			return -1;
		double result = 0;
		for(int i = 0; i < color1.length; i++) {
			result += (Math.pow(color1[i] - color2[i], 2));
		}
		return Math.sqrt(result/3);
	}

	public static int distBox(Color color1, Color color2) {
		return (Math.abs(color1.getRed()-color2.getRed()) 
				+ Math.abs(color1.getGreen()- color2.getGreen()) + Math.abs(color1.getBlue() - color2.getBlue()))/3;
	}

	//------------------------------------------------------------------------------------------------
	//  Creates a split pane JFrame for managing two text files, where one is editable, and the other
	//  is derived from the first by mutating its contents with the Garbler class.
	//------------------------------------------------------------------------------------------------
	public static void main (String[] args) throws Exception {
		if(args.length == 0) {
		JFrame frame = new JFrame ("Image Processor");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		InputPanel inPanel = new InputPanel ();

		//JSplitPane pane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, inPanel, inPanel.outPanel);
		frame.getContentPane().add(inPanel);
		frame.pack();
		frame.setVisible(true);
		printHelp();
		}
		else {
		final int SCALEDCOMPARE = 3, FINDMATCHING = 4, REVERSEPERSPECTIVE = 5;
		String file1, file2 = "Blank.jpg";
		BufferedImage image1, image2 = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);
		int operation, arg3 = 0, arg4 = 0, arg5 = 3;
		if(args.length > 0) {
			try {
				operation = Integer.parseInt(args[0]);
			}
			catch(Exception e) {printHelp(); return;}
			if(args.length > 1) {
				file1 = args[1];
				image1 = ImageIO.read(new File(file1));
				if(args.length > 2) {
					file2 = args[2];
					image2 = ImageIO.read(new File(file2));
					if(args.length > 5) {
						arg3 = Integer.parseInt(args[3]);
						arg4 = Integer.parseInt(args[4]);
						arg5 = Integer.parseInt(args[5]);
					}
				}
				//try {
				switch(operation) {
				case SCALEDCOMPARE: System.out.println("Difference: " + scaledDifference(file1, file2)); break;
				case FINDMATCHING: 
					int[] closest = findMatchingPoint(image1, image2, arg3, arg4, arg5);
					System.out.println("Closest match to " + arg3 + ", " + arg4 + " found at " + closest[0] + ", " + closest[1] + " with a difference of " + closest[2] );
					break;
				case REVERSEPERSPECTIVE:
					Mesh m = reversePerspective(image1, image2, arg3);
					m.printObject();
					break;
				}
				//}
				//catch(Exception e) {System.err.println("A file error occurred.");}
			}
		}
		}
	}

	public static void printHelp() {
		System.out.println("Java Image Operations\nUsage: java Image [opNum] [filename1] [filename2]" +
				"\nOperations: \n\t1. Determine equality\n\t2. Subtract\n\t3. Scaled comparison (absolute)");
	}
	


}